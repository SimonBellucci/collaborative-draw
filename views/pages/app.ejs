<!DOCTYPE html>
<html lang="fr" dir="ltr" class="app">
    <head>
		<meta charset="UTF-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	    <meta http-equiv="X-UA-Compatible" content="ie=edge">
	    <link rel="stylesheet" href="../mincss/styles.css">
	    <title>WeMake - App</title>
    </head>
    <body>
        <header class="container-fluid app-header">
            <div class="row align-center">
                <div class="col-lg-6">
                    <nav class="menu">
                        <a href="#" class="menu__icon"><img src="../images/menu.svg" alt="Menu"></a>
                        <ul class="menu__sub">
                            <li class="menu__sub__link"><a href="/mes-projets" title="Mes projets">Mes projets</a></li>
                            <li class="menu__sub__link"><a href="/mes-collaborations" title="Mes collaborations">Mes collaborations</a></li>
                            <li class="menu__sub__link"><a href="/galerie" title="Galerie publique">Galerie publique</a></li>
                            <li class="menu__sub__link"><a href="/deconnexion" title="Déconnexion">Déconnexion</a></li>
                        </ul>
                    </nav>
                </div>
                <h1 class="project-name text-center"><%= infos[0].title %></h1>
                <div class="col-lg-6 d-flex justify-end">
                    <div class="people d-flex align-center">
                        <img class="people__icon" src="../images/add-people.svg" alt="">
                        <span class="people__number"><%= count %></span>
                        <a href="#" class="people__add">
                            <img src="../images/add.svg" alt="Add people" title="Add">
                        </a>
                        <form action="/add-user/<%= infos[0].id %>" method="POST" class="people__sub">
                            <input class="people__sub__input" type="email" name="email" placeholder="Saisissez l'email du collaborateur">
                            <button type="submit" class="people__sub__validate button button--blue" type="submit">Inviter</button>
                        </form>
                    </div>
                    <a href="#" class="export button button--purple" title="Exporter">Exporter</a>
                </div>
            </div>
        </header>
        <section class="tools">
            <div class="tools__item">
                <label for="file"><img src="../images/import.svg" alt="Settings"></label>
                <input type="file" class="tools__item__files" id="file" name="" value="" style="background:url('../images/import.svg')">
            </div>
            <div class="tools__item">
                <img src="../images/settings.svg" alt="Settings">
                <img src="../images/arrow.svg" alt="Sub" class="tools__item__sub-img">
                <ul class="tools__item__sub">
                    <li class="tools__item__sub__item">Contraste</li>
                    <li class="tools__item__sub__item">Luminosité</li>
                </ul>
            </div>
            <div class="tools__item">
                <img src="../images/filters.svg" alt="Filters">
                <img src="../images/arrow.svg" alt="Sub" class="tools__item__sub-img">
                <ul class="tools__item__sub">
                    <li class="tools__item__sub__item">Noir et blanc</li>
                    <li class="tools__item__sub__item">Sépia</li>
                </ul>
            </div>
            <div class="tools__item">
                <img src="../images/shapes.svg" alt="Shapes">
                <img src="../images/arrow.svg" alt="Sub" class="tools__item__sub-img">
                <ul class="tools__item__sub">
                    <button class="tools__item__sub__item" type="button" name="button" id="freeDraw">Dessin</button>
                    <button class="tools__item__sub__item shape" type="button" name="button" id="createCircle">Cercle</button>
                    <button class="tools__item__sub__item shape" type="button" name="button" id="createRect">Rectangle</button>
                    <button class="tools__item__sub__item shape" type="button" name="button" id="createTriangle">Triangle</button>
                </ul>
            </div>
            <div class="tools__item">
                <img src="../images/text.svg" alt="Text">
            </div>
            <div class="tools__item">
                <img src="../images/crop.svg" alt="Crop">
            </div>
            <div class="tools__item">
                <input type="color" name="" value="#278bff" id="colorPicker">
            </div>
        </section>

        <section class="chat">
            <div class="chat__header" id="chat-count"></div>
            <ul class="chat__messages" id="chat-container"></ul>
            <hr />
            <div class="chat__text">
                <input class="chat__text__input" id="chat-input" type="text" placeholder="Votre message...">
                <button class="chat__text__submit" id="chat-send"></button>
            </div>
        </section>



        <canvas id="canvasTest" width="<%= infos[0].width %>" height="<%= infos[0].height %>"></canvas>

        <!-- <input type="text" name="" value="" id="radiusValue"> -->

        <script src="../socket.io/socket.io.js" charset="utf-8"></script>
        <script src="../minjs/fabric.min.js" charset="utf-8"></script>
        <script type="text/javascript">
          window.onload = () => {

            var $ = function(id){return document.getElementById(id)};

            //Initialisation de socket.io
            const socket = io.connect();

            //Mise en place de la room avec l'ID du projet
            const room = "<%= infos[0].id %>";

            socket.on('connect', function() {
               socket.emit('room', room);
            });

            socket.on('message', function(data) {
               console.log(data);
            });

            //Chat
            const chatContainer = $('chat-container');
            const chatMsg = $('chat-input');
            const chatSend = $('chat-send');
            const chatCount = $('chat-count');

            chatSend.addEventListener('click', () => {
              socket.emit('chatMsg', {room: room, username: "<%= username %>", message: chatMsg.value});
              setTimeout(() => {
                chatMsg.value = "";
              }, 10);
            });

            chatMsg.addEventListener('keypress', (e) => {
              if(e.keyCode === 13){
                socket.emit('chatMsg', {room: room, username: "<%= username %>", message: chatMsg.value});
                setTimeout(() => {
                  chatMsg.value = "";
                }, 10);
              }
            });

            socket.on('newChatMsg', data => {
              chatContainer.innerHTML +=
              '<li class="chat__messages__li">'+
                '<span class="chat__messages__li__author">'+data.username+' : '+'</span>'+data.message+
              '</li>';

            })

            // let lastTypedTime = new Date(0);
            // const typingDelay = 5000;
            //
            // function refreshTypingStatus() {
            //     let isTyping = false;
            //
            //     if(chatMsg.value === '' || new Date().getTime() - lastTypedTime.getTime() > typingDelay) {
            //         isTyping = false;
            //         socket.emit('chatTyping', {room: room, username: "<%= username %>", isTyping: isTyping})
            //     } else {
            //         isTyping = true;
            //         socket.emit('chatTyping', {room: room, username: "<%= username %>", isTyping: isTyping});
            //     }
            // }
            //
            // function updateLastTypedTime() {
            //     lastTypedTime = new Date();
            // }



            // setInterval(refreshTypingStatus, 1000);

            chatMsg.addEventListener('keyup', () => {
                let isTyping = false;

                if(chatMsg.value.length > 0){
                  isTyping = true;
                  checkTyping(isTyping);
                }
                else{
                  isTyping = false;
                  checkTyping(isTyping);
                }

            });
            let flag = 0;
            function checkTyping(typing){


              if(typing && flag === 0){
                socket.emit('chatTyping', {room: room, username: "<%= username %>", isTyping: true});
                flag = 1;
              }
              else if(!typing){
                socket.emit('chatTyping', {room: room, username: "<%= username %>", isTyping: false});
                flag = 0;
              }
            }

            socket.on('typingStatus', data => {

              let statusDiv = document.createElement("li");
              statusDiv.setAttribute('class', 'chat__messages__li chat__status');

              let statusSpan = document.createElement("span");
              statusSpan.setAttribute('class', 'chat__messages__li__author');

              let spanContent = document.createTextNode(data.user+' : ');

              let statusImg = document.createElement("img");
              statusImg.setAttribute('class', 'chat__status__img');
              statusImg.setAttribute('src', '../images/typing.gif');

              statusDiv.appendChild(statusSpan);
              statusSpan.appendChild(spanContent);
              statusSpan.appendChild(statusImg);

              if(data.status){
                chatContainer.appendChild(statusDiv);
                // '<li class="chat__messages__li" style="background: #FFF; position: relative">'+
                //   '<span class="chat__messages__li__author">'+data.user+' : '+'</span>'+'<img src="../images/typing.gif" style="position: absolute;top: -80px; left: -44px;transform: scale(0.15);">'+
                // '</li>';
              }
              else if(!data.status){
                let div = document.getElementsByClassName('chat__status');
                chatContainer.removeChild(div[0]);
              }
            })

            socket.on('numberConnected', data => {
              console.log(data);
              if(data === 1){
                chatCount.innerHTML = 'Connecté ( '+data+' )';
              }
              else{
                chatCount.innerHTML = 'Connectés ( '+data+' )';
              }

            })

            //Récupération des boutons de création de formes
            const shapeButton = document.getElementsByClassName('shape');
            const circleButton = $('createCircle');
            const createRect = $('createRect');
            const createTriangle = $('createTriangle');

            //Récupération des boutons de changements de couleur
            const colorPicker = $('colorPicker');

            //Récupération import d'image
            const importButton = $('file');

            importButton.addEventListener('change', (e) => {
              upload(e);
            })

            colorPicker.addEventListener('change', (e) => {
              changeColor(e.target.value);
            });

            let color = 'black';

            function changeColor(colored){
              return color = colored;
            }

            //Création du Canvas
            const canvas = new fabric.Canvas('canvasTest', {
              isDrawingMode: false
            });

            let jsonDb = "<%= infos[0].render %>";
            let json = jsonDb.replace(/&#34;/g, '"');

            console.log(json);
            canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));

            canvas.selection = false;

            //Envoi du JSON vers Server
            function sendData(){
              let id = "<%= infos[0].id %>";
              let serializedCanvas = JSON.stringify(canvas.toJSON(['id', 'lockMovementX', 'lockMovementY', 'lockScalingX', 'lockScalingY', 'lockRotation']));
              console.log('Saved');
              let image = canvas.toDataURL('jpeg');
              socket.emit('connectionCanvas', {canvas: serializedCanvas, id: id, image: image});
            }

            //Enregistrement toutes les 10 secs
            setInterval(() => {
              sendData();
            },10000)

            //Ratio image
            function sizeCalc(imgWidth, imgHeight) {
              let width_ratio = canvas.width / 2 / imgWidth;
              let height_ratio = canvas.height / 2 / imgHeight;

              let ratio = null;

              // if (width_ratio > height_ratio)
              if (imgWidth >= imgHeight)
                ratio = width_ratio;
              else
                ratio = height_ratio;

              let height = canvas.height / 2 / ratio;
              let width = (canvas.width / 2) / ratio;

              let cH = canvas.height / 2;
              let nH = imgHeight * ratio;
              let cropY = (nH - cH) / ratio / 2;

              let cW = canvas.width / 2;
              let nW = imgWidth * ratio;
              let cropX = (nW - cW) / ratio / 2;

              let returnObj = {
                width_ratio: ratio,
                height_ratio: ratio,
                width: width,
                height: height
              };

              if (width_ratio > height_ratio) returnObj.cropY = cropY;
              else returnObj.cropX = cropX;

              return returnObj;
            }

            fabric.Image.prototype.toObject = (function(toObject) {
              return function() {
                return fabric.util.object.extend(toObject.call(this), {
                  src: this.toDataURL(),
                  height: this.height,
                  width: this.width,
                  matrixCache: this.matrixCache,
                  ownMatrixCache: this.ownMatrixCache,
                  scaleY: this.scaleY,
                  scaleX: this.scaleX,
                  cropX: this.cropX,
                  cropY: this.cropY
                });
              };
            })(fabric.Image.prototype.toObject);

            //Import d'image
            function upload(e) {
               let fileType = e.target.files[0].type;
               let url = URL.createObjectURL(e.target.files[0]);

               if (fileType === 'image/jpeg') { //check if png
                  fabric.Image.fromURL(url, function(img) {
                    let size = sizeCalc(img.width, img.height);
                     img.set({
                       left:20,
                       top: 20,
                       height: size.height,
                       width: size.width,
                       scaleY: size.height_ratio,
                       scaleX: size.width_ratio,
                       cropY: size.cropY ? size.cropY : false,
                       cropX: size.cropX ? size.cropX : false
                     });
                     canvas.add(img);
                  });
               } else if (fileType === 'image/svg+xml') { //check if svg
                  fabric.loadSVGFromURL(url, function(objects, options) {
                     var svg = fabric.util.groupSVGElements(objects, options);
                     svg.scaleToWidth(180);
                     svg.scaleToHeight(180);
                     canvas.add(svg);
                  });
               }

               sendData();

            }

            //FreeDraw | Temps réel : http://jsfiddle.net/B5Ub9/4/
            const freeDraw = $('freeDraw');

            freeDraw.addEventListener('click', (e) => {
              if(canvas.isDrawingMode == false){
                canvas.isDrawingMode = true;
              }
              else{
                canvas.isDrawingMode = false;
              }
            });

            canvas.on('path:created', (opt) => {
              opt.path.id = fabric.Object.__uid++
              opt.path.lockMovementX = true;
              opt.path.lockMovementY = true;
              opt.path.lockScalingX = true;
              opt.path.lockScalingY = true;
              opt.path.lockRotation = true;
              socket.emit('pathAdded')
              sendData();
            });

            canvas.on('object:added', sendData);

            canvas.on('object:selected', onObjectSelected);

            function onObjectSelected(e){
            	let self = e.target;
              console.log(self);
            }

            canvas.on('object:scaling', onObjectScaled);

            function onObjectScaled(e){
            	let self = e.target;
              socket.emit('newScale', {scaleX: self.get('scaleX'), scaleY: self.get('scaleY'), id: self.id})
            }

            canvas.on('object:moving', objectMoving);

            function objectMoving(e){
              let self = e.target;
              socket.emit('newCoords', {room: room, top: self.top, left: self.left, id: self.id});
            }

            function drawObject(data){
              if(data.type == 'circle'){

                const circle = new fabric.Circle({
                  radius: 100,
                  fill: data.color,
                  left: canvas.width/2,
                  top: canvas.height/2,
                  selectable: true
                });

                circle.toObject = (function(toObject) {
                return function() {
                  return fabric.util.object.extend(toObject.call(this), {
                      id: this.id
                    });
                  };
                })(circle.toObject);


                const rect = new fabric.Rect({
                    width: 10,
                    height: 20,
                    fill: data.color,
                    opacity: 0.7,
                    top: canvas.height/2,
                    left: canvas.width/2,
                 });



                circle.id = data.id;

                canvas.add(circle);
            } else if(data.type == 'rect'){

                const rect = new fabric.Rect({
                    width: 100,
                    height: 200,
                    fill: data.color,
                    top: canvas.height/2,
                    left: canvas.width/2,
                 });

                rect.toObject = (function(toObject) {
                return function() {
                  return fabric.util.object.extend(toObject.call(this), {
                      id: this.id
                    });
                  };
                })(rect.toObject);

                rect.id = data.id;

                canvas.add(rect);
              } else if(data.type == 'triangle'){

                  const triangle = new fabric.Triangle({
                      width: 100,
                      height: 200,
                      fill: data.color,
                      top: canvas.height/2,
                      left: canvas.width/2,
                   });

                  triangle.toObject = (function(toObject) {
                  return function() {
                    return fabric.util.object.extend(toObject.call(this), {
                        id: this.id
                      });
                    };
                  })(triangle.toObject);

                  triangle.id = data.id;

                  canvas.add(triangle);
                }
            }

            document.addEventListener('keydown', e => {
              if(e.keyCode == '8' || e.keyCode == '46'){
                canvas.getActiveObject().visible = false;
                sendData();
              }
            }, false);

            socket.on('getNewObject', data => {
              drawObject(data);
            });

            circleButton.addEventListener('click', () => {
              socket.emit('objectAdded', {type: 'circle', color: color});
            });

            createRect.addEventListener('click', () => {
              socket.emit('objectAdded', {type: 'rect', color: color});
            });

            createTriangle.addEventListener('click', () => {
              socket.emit('objectAdded', {type: 'triangle', color: color});
            });

          socket.on('getNewCoords', data => {
            let allObjects = canvas.getObjects();

            //console.log(allObjects);
            allObjects[data.id].top = data.top;
            allObjects[data.id].left = data.left;

            canvas.renderAll();

          });

          socket.on('getNewScale', data => {
            let allObjects = canvas.getObjects();

            allObjects[data.id].scaleX = data.scaleX;
            allObjects[data.id].scaleY = data.scaleY;

            canvas.renderAll();

          });

            //On récupère le canvas à la ocnnection
            // socket.on('getConnectionCanvas', data => {
            //   console.log('New Data = '+data)
            //   canvas.loadFromJSON(data);
            // })

          }
        </script>
        <script src="../minjs/script.js"></script>
    </body>
</html>
