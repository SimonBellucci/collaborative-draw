<!DOCTYPE html>
<html lang="fr" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Canvas Test</title>
  </head>
  <body>
    <h1>Test</h1>
    <canvas id="canvasTest" width="400" height="400"></canvas>
    <button type="button" name="button" id="freeDraw">Dessiner</button>
    <button type="button" name="button" id="createCircle" class="shape">Cercle</button>
    <input type="color" name="" value="" id="colorPicker">

    <script src="/socket.io/socket.io.js" charset="utf-8"></script>
    <script src="/js/fabric.min.js" charset="utf-8"></script>
    <script type="text/javascript">
      window.onload = () => {

        var $ = function(id){return document.getElementById(id)};

        //Initialisation de socket.io
        const socket = io('/');

        //Récupération des boutons de création de formes
        const shapeButton = document.getElementsByClassName('shape');
        const circleButton = $('createCircle');

        //Récupération des boutons de changements de couleur
        const colorPicker = $('colorPicker');

        colorPicker.addEventListener('change', (e) => {
          changeColor(e.target.value);
        });

        let color = 'black';

        function changeColor(colored){
          return color = colored;
        }

        // create a wrapper around native canvas element (with id="c")
        const canvas = new fabric.Canvas('canvasTest', {
          isDrawingMode: false
        });

        function objectAdded(){
          socket.emit('newObject');
        }

        Array.from(shapeButton).forEach(function(element) {
          element.addEventListener('click', objectAdded);
        });


        socket.on('getNewObject', data => {
          console.log(data.id);
        });

        //FreeDraw | Temps réel : http://jsfiddle.net/B5Ub9/4/
        const freeDraw = $('freeDraw');

        freeDraw.addEventListener('click', (e) => {
          if(canvas.isDrawingMode == false){
            canvas.isDrawingMode = true;
          }
          else{
            canvas.isDrawingMode = false;
          }
        });

        canvas.on('path:created', () => {
          console.log('path')
        });

        canvas.on('object:selected', onObjectSelected);

        function onObjectSelected(e){
        	let self = e.target;
          console.log(self);
        }

        canvas.on('object:scaling', onObjectScaled);

        function onObjectScaled(e){
        	let self = e.target;
          socket.emit('newScale', {scaleX: self.get('scaleX'), scaleY: self.get('scaleY'), id: self.id})
        }

        canvas.on('object:moving', objectMoving);

        function objectMoving(e){
          let self = e.target;
          socket.emit('newCoords', {top: self.top, left: self.left, id: self.id});
        }

        canvas.on('object:added', objectAdded);

        circleButton.addEventListener('click', () => {

          const circle = new fabric.Circle({
            radius: 100,
            fill: color,
            left: canvas.width/2,
            top: canvas.height/2,
          });

          circle.toObject = (function(toObject) {
          return function() {
            return fabric.util.object.extend(toObject.call(this), {
                id: this.id
              });
            };
          })(circle.toObject);

          circle.id = 1;

          // circle.id = count;

          canvas.add(circle);
          //count++ //LE COUNT DOIT SE FAIRE AU NIVEAU DU SERVEUR

          //Serialization
          let serializedCanvas = JSON.stringify(canvas);
          socket.emit('connectionCanvas', serializedCanvas);

        });

      socket.on('getNewCoords', data => {
        let allObjects = canvas.getObjects();

        //console.log(allObjects[data.id]);
        allObjects[data.id].top = data.top;
        allObjects[data.id].left = data.left;

        canvas.renderAll();

      });

      // socket.on('getNewObject', data => {
      //   let count = data.id;
      // });

      socket.on('getNewScale', data => {
        let allObjects = canvas.getObjects();

        allObjects[data.id].scaleX = data.scaleX;
        allObjects[data.id].scaleY = data.scaleY;

        canvas.renderAll();

      });

      // myCanvas.getObjects().indexOf(myObject)

        //On récupère le canvas à la ocnnection
        socket.on('getConnectionCanvas', data => {
          console.log('New Data = '+data)
          canvas.loadFromJSON(data);
        })

      }
    </script>
  </body>
</html>
